diff -pruN oiio-Release-1.7.16.orig/src/python/py_imagebuf.cpp oiio-Release-1.7.16/src/python/py_imagebuf.cpp
--- oiio-Release-1.7.16.orig/src/python/py_imagebuf.cpp	2017-08-28 11:54:33.891421651 +0800
+++ oiio-Release-1.7.16/src/python/py_imagebuf.cpp	2017-08-28 12:13:15.777449672 +0800
@@ -346,7 +346,7 @@ ImageBuf_set_deep_value_uint (ImageBuf &
 
 
 bool
-ImageBuf_set_pixels_tuple (ImageBuf &buf, ROI roi, tuple data)
+ImageBuf_set_pixels_tuple (ImageBuf &buf, ROI roi, const tuple& data)
 {
     if (! roi.defined())
         roi = buf.roi();
@@ -364,8 +364,13 @@ ImageBuf_set_pixels_tuple (ImageBuf &buf
 
 
 bool
-ImageBuf_set_pixels_array (ImageBuf &buf, ROI roi, numeric::array data)
+ImageBuf_set_pixels_array (ImageBuf &buf, ROI roi, const object& data)
 {
+    // If it's a tuple. we handle that with the other function
+    extract<tuple> tup (data);
+    if (tup.check())
+        return ImageBuf_set_pixels_tuple (buf, roi, tup());
+
     if (! roi.defined())
         roi = buf.roi();
     roi.chend = std::min (roi.chend, buf.nchannels()+1);
@@ -373,13 +378,15 @@ ImageBuf_set_pixels_array (ImageBuf &buf
     if (size == 0)
         return true;   // done
 
-    TypeDesc type;
-    size_t pylen = 0;
-    const void *addr = python_array_address (data, type, pylen);
-    if (!addr || size > pylen)
+    TypeDesc elementtype;
+    size_t numelements;
+    const void* addr = python_array_address (data, elementtype, numelements);
+    if (!addr || size > numelements)
         return false;   // Not enough data to fill our ROI
-
-    buf.set_pixels (roi, type, addr);
+    std::vector<float> vals (numelements);
+    convert_types (elementtype, addr, TypeDesc::TypeFloat, vals.data(),
+                   int(numelements));
+    buf.set_pixels (roi, TypeDesc::TypeFloat, &vals[0]);
     return true;
 }
 
diff -pruN oiio-Release-1.7.16.orig/src/python/py_imageoutput.cpp oiio-Release-1.7.16/src/python/py_imageoutput.cpp
--- oiio-Release-1.7.16.orig/src/python/py_imageoutput.cpp	2017-08-28 11:54:33.891421651 +0800
+++ oiio-Release-1.7.16/src/python/py_imageoutput.cpp	2017-08-28 12:17:30.810456042 +0800
@@ -112,7 +112,7 @@ ImageOutputWrap::make_read_buffer (objec
 
 
 bool
-ImageOutputWrap::write_scanline_array (int y, int z, numeric::array &buffer)
+ImageOutputWrap::write_scanline_array (int y, int z, object &buffer)
 {
     TypeDesc format;
     size_t numelements = 0;
@@ -154,7 +154,7 @@ ImageOutputWrap::write_scanline_bt (int
 
 bool
 ImageOutputWrap::write_scanlines_array (int ybegin, int yend, int z,
-                                        numeric::array &buffer)
+                                        object &buffer)
 {
     TypeDesc format;
     size_t numelements = 0;
@@ -199,7 +199,7 @@ ImageOutputWrap::write_scanlines_bt (int
 
 bool
 ImageOutputWrap::write_tile_array (int x, int y, int z,
-                                   numeric::array &buffer)
+                                   object &buffer)
 {
     TypeDesc format;
     size_t numelements = 0;
@@ -243,7 +243,7 @@ ImageOutputWrap::write_tile_bt (int x, i
 bool
 ImageOutputWrap::write_tiles_array (int xbegin, int xend, int ybegin, int yend,
                                     int zbegin, int zend,
-                                    numeric::array &buffer)
+                                    object &buffer)
 {
     TypeDesc format;
     size_t numelements = 0;
@@ -290,7 +290,7 @@ ImageOutputWrap::write_tiles_bt (int xbe
 
 
 bool
-ImageOutputWrap::write_image_array (numeric::array &buffer)
+ImageOutputWrap::write_image_array (object &buffer)
 {
     TypeDesc format;
     size_t numelements = 0;
diff -pruN oiio-Release-1.7.16.orig/src/python/py_oiio.cpp oiio-Release-1.7.16/src/python/py_oiio.cpp
--- oiio-Release-1.7.16.orig/src/python/py_oiio.cpp	2017-08-28 11:54:33.891421651 +0800
+++ oiio-Release-1.7.16/src/python/py_oiio.cpp	2017-08-28 12:25:47.138468438 +0800
@@ -78,6 +78,13 @@ typedesc_from_python_array_code (char co
 }
 
 
+std::string
+object_classname(const object& obj)
+{
+    return extract<std::string>(obj.attr("__class__").attr("__name__"));
+}
+
+
 
 object
 C_array_to_Python_array (const char *data, TypeDesc type, size_t size)
@@ -313,11 +320,18 @@ oiio_get_string_attribute_d (const char
 
 
 const void *
-python_array_address (numeric::array &data, TypeDesc &elementtype,
+python_array_address (const object &data, TypeDesc &elementtype,
                       size_t &numelements)
 {
     // Figure out the type of the array
-    object tcobj = data.attr("typecode");
+    object tcobj;
+    try {
+        tcobj = data.attr("typecode");
+    } catch(...){
+        return NULL;
+    }
+    if (! tcobj)
+        return NULL;
     extract<char> tce (tcobj);
     char typecode = tce.check() ? (char)tce : 0;
     elementtype = typedesc_from_python_array_code (typecode);
@@ -395,7 +409,9 @@ OIIO_DECLARE_PYMODULE(OIIO_PYMODULE_NAME
     scope().attr("VERSION_PATCH") = OIIO_VERSION_PATCH;
     scope().attr("INTRO_STRING") = OIIO_INTRO_STRING;
 
+#if BOOST_VERSION < 106500
     boost::python::numeric::array::set_module_and_type("array", "array");
+#endif
 }
 
 } // namespace PyOpenImageIO
diff -pruN oiio-Release-1.7.16.orig/src/python/py_oiio.h oiio-Release-1.7.16/src/python/py_oiio.h
--- oiio-Release-1.7.16.orig/src/python/py_oiio.h	2017-08-28 11:54:33.892421651 +0800
+++ oiio-Release-1.7.16/src/python/py_oiio.h	2017-08-28 12:32:30.425478511 +0800
@@ -69,12 +69,13 @@ bool PyProgressCallback(void*, float);
 object C_array_to_Python_array (const char *data, TypeDesc type, size_t size);
 const char * python_array_code (TypeDesc format);
 TypeDesc typedesc_from_python_array_code (char code);
+std::string object_classname (const object& obj);
 
 
 // Given python array 'data', figure out its element type and number of
 // elements, and return the memory address of its contents.  Return NULL as
 // the address for an error.
-const void * python_array_address (numeric::array &data, TypeDesc &elementtype,
+const void * python_array_address (const object &data, TypeDesc &elementtype,
                                    size_t &numelements);
 
 
@@ -89,7 +90,7 @@ void py_to_stdvector (std::vector<T> &va
         for (int i = 0, e = len(tup()); i < e; ++i)
             py_to_stdvector<T> (vals, tup()[i]);
     } else {
-        // non-tuple case
+        // non-tuple case (presumably scalar)
         extract<T> t (obj);
         vals.push_back (t.check() ? t() : T());
     }
@@ -106,16 +107,6 @@ void py_to_stdvector (std::vector<T> &va
 
 
 
-// Suck up a tuple of presumed T values into a vector<T>
-template<typename T>
-void py_to_stdvector (std::vector<T> &vals, const numeric::array &arr)
-{
-    for (int i = 0, e = len(arr); i < e; ++i)
-        vals.push_back (extract<T>(arr[i]));
-}
-
-
-
 // Convert an array of T values into either tuple. FUNC is a conversion
 // function such as PyInt_FromLong, PyFloat_FromDouble, or
 // PyString_FromString.
@@ -313,12 +304,12 @@ public:
                          stride_t xstride=AutoStride);
     bool write_scanline_bt (int, int, TypeDesc::BASETYPE,
                             boost::python::object&, stride_t xstride=AutoStride);
-    bool write_scanline_array (int, int, numeric::array&);
+    bool write_scanline_array (int, int, object&);
     bool write_scanlines (int, int, int, TypeDesc, boost::python::object&,
                          stride_t xstride=AutoStride);
     bool write_scanlines_bt (int, int, int, TypeDesc::BASETYPE,
                             boost::python::object&, stride_t xstride=AutoStride);
-    bool write_scanlines_array (int, int, int, numeric::array&);
+    bool write_scanlines_array (int, int, int, object&);
     bool write_tile (int, int, int, TypeDesc, boost::python::object&,
                      stride_t xstride=AutoStride, stride_t ystride=AutoStride,
                      stride_t zstride=AutoStride);
@@ -326,7 +317,7 @@ public:
                         boost::python::object&, stride_t xstride=AutoStride,
                         stride_t ystride=AutoStride,
                         stride_t zstride=AutoStride);
-    bool write_tile_array (int, int, int, numeric::array&);
+    bool write_tile_array (int, int, int, object&);
     bool write_tiles (int, int, int, int, int, int,
                       TypeDesc, boost::python::object&,
                       stride_t xstride=AutoStride, stride_t ystride=AutoStride,
@@ -336,7 +327,7 @@ public:
                          stride_t xstride=AutoStride,
                          stride_t ystride=AutoStride,
                          stride_t zstride=AutoStride);
-    bool write_tiles_array (int, int, int, int, int, int, numeric::array&);
+    bool write_tiles_array (int, int, int, int, int, int, object&);
     bool write_image (TypeDesc format, object &buffer,
                       stride_t xstride=AutoStride,
                       stride_t ystride=AutoStride,
@@ -345,7 +336,7 @@ public:
                          stride_t xstride=AutoStride,
                          stride_t ystride=AutoStride,
                          stride_t zstride=AutoStride);
-    bool write_image_array (numeric::array &buffer);
+    bool write_image_array (object &buffer);
     bool write_deep_scanlines (int ybegin, int yend, int z,
                                const DeepData &deepdata);
     bool write_deep_tiles (int xbegin, int xend, int ybegin, int yend,
